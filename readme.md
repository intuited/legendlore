## dnd5edb ##

Documentation last updated 2021-04-11

Python API to run queries on and format data from XML data for D&D 5th ed.

The XML data is built for an Android app called Fight Club and is not licensed content.
As such, it may be somewhat difficult to locate.  Most recently, it appears to live in [this DropBox][0]

The purpose of this code is to enable convenient programmatic access to the database.

### REPL usage

It is particularly useful in a REPL like [iPython][1].  To setup convenient access, it can be useful to issue commands such as the following:

    >>> from dnd5edb.repl import *
    >>> from dnd5edb import Spells, Monsters
    >>> from dnd5edb import predicates as p

Currently, only the spells and monsters aspects of the database are properly implemented.

### Usage

A basic query can give us a list of all level 9 spells in the game:

    >>> s.where(level=9).print()

For example, to list all level 4 Bard spells, sorted by level:

    >>> s.where(level=4, classes=p.in_('Bard')).sorted('level')
    [Spell(Compulsion A/30'/C<=1m (4:B)),
     Spell(Confusion A/90'/C<=1m (4:B+D+AT+S+Wz)),
     Spell(Dimension Door A/500'/I (4:B+S+Wl+Wz)),
     Spell(Freedom of Movement A/T/1h (4:A+B+C+D+Ra)),
     Spell(Greater Invisibility A/T/C<=1m (4:B+B+RGS+AT+S+WlA+Wz)),
     Spell(Hallucinatory Terrain 10m/300'/24h (4:B+D+AT+Wl+Wz)),
     Spell(Locate Creature A/S/C<=1h (4:B+C+D+P+Ra+WlR+WlS+Wz)),
     Spell(Polymorph A/60'/C<=1h (4:B+D+S+Wz)),
     Spell(Charm Monster A/30'/1h (4:B+D+AT+S+Wl+Wz))]

This last example uses predicates.

### Predicates

Predicates are generated by calling one of the factory functions in `dnd5edb.predicates`.

The closure returned by a predicate factory is a function of the form `f(attr, obj)`.

When the closure is called, it compares the value supplied to the factory with the 'attr' attribute of the object 'obj'.
If the object does not have that attribute, or if the comparison is false, a `False` value is returned.
Otherwise, a the closure returns `True`.

The `Spells.where` method runs this comparison on all the spells in that collection,
and returns a list of the ones for which the predicate evaluated to `True`.

In the previous example, the `in_` predicate checks whether `'Bard'` is one of the items in the list of strings
stored in the `'classes'` attribute of `obj`.

#### Predicates: tl;dr

All you need to know to use predicates is that they are function calls
passed as the value of keyword arguments to the `where` methods
of `Spells` and `Monsters` collections.

#### Composite predicates

Here we have another example using predicates.  This code gives us a printout of all Ranger spells between 2nd and 3rd level:

    >>> s.where( classes=p.in_('Ranger'),
    ...          level=p.and_(p.gte(2), p.lte(3)) ).sorted('level').print()

The `and_` predicate is simply a predicate that checks the values of two or more other predicates.

Ever wanted to know which spells are available to sorcerers but not wizards?

    >>> s.where(classes=p.and_(p.contains('Sorcerer'), p.not_(p.contains('Wizard'))))
    [Spell(Chaos Bolt A/120'/I [V/S] (1:S)),
     Spell(Daylight A/60'/1h [V/S] (3:C+CLt+D+DL+P+Ra+S+WlC)),
     Spell(Water Walk (rit.) A/30'/1h [V/S] (3:A+C+D+DL+Ra+S)),
     Spell(Dominate Beast A/60'/C<=1m [V/S] (4:CN+D+PCo+S+WlA+WlGOO)),
     Spell(Insect Plague A/300'/C<=10m [V/S] (5:C+CN+CTm+D+DL+RaS+S)),
     Spell(Fire Storm A/150'/I [V/S] (7:C+D+S)),
     Spell(Earthquake A/500'/C<=1m [V/S] (8:C+D+S))]

Current predicates are:

    - `eq`: equivalent to Python's `==` operator
    - `lt`, `lte`, `gt`, `gte`: numeric comparisons equivalent to `<`, `<=`, etc.
    - `key`: checks for the presence of a key in dictionary fields
    - `in_`: equivalent to `in` operator
    - `and_`: `True` if all of the passed predicates return `True`
    - `or_`: `True` if at least one of the passed predicates returns `True`

#### Using custom predicates

You can also pass your own predicates to `where`.  What's that race that starts with "aa" again?

    >>> m.where(name=lambda attr, obj: getattr(obj, attr, '').startswith('aa')).print()
    Monster({'name': Aarakocra, 'type': humanoid (aarakocra)})

Predicates need to be type-safeâ€”in other words, they should safely return `False` if the attribute is not present in an object.

### Format options

Currently, monster and spell objects have three format options.

#### `'oneline'`

The default `'oneline'` format generates a single-line summary of the object's vital statistics.  EG

    >>> s.where(name='Magic Missile').print()
    >>> s.where(name='Magic Missile').print('oneline')

##### Class abbreviations

The `'oneline'` format uses two- to three-letter abbreviations to summarize the classes of casters with access to the spell.

These are as follows:

#TODO

#### `'full'`

Specifying the `'full'` format produces complete\* information about the item:

    >>> s.where(name='Magic Missile').print('full')

\*: currently, some information is missing for Monsters, e.g. attacks

#### `'point'`

The `'point'` format yields a header summary (identical to the `'oneline'` output)
followed by indented lines containing the rest of the information for the item.

For spells, the indented lines simply contain the spell text.

    >>> s.where(name='Magic Missile').print('point')
    - Magic Missile A/120'/I (1:FEK+S+Wz)
      - You create three glowing darts of magical force. Each dart hits a creature...
      - 
      - At Higher Levels: When you cast this spell using a spell slot of 2nd...

### Fields

Any field that is present in an item of a given type can be used as a keyword argument to the `where` method.

#### Spell fields

The following fields occur in one or more spell items:

    - `'name'`: String containing the properly capitalized name of the spell
    - `'roll'`: String containing the dice to be rolled as part of casting, if applicable
        - this information is not presented in spell formatting (though it is invariably also present in the spell text)
    - `'classes'`: List of strings, each containing the name of a character class or class subtype
        - e.g. 'Wizard', 'Rogue (Arcane Trickster')
        - subtypes are always written according to f'{class} ({subclass})' where both `class` and `subclass` are properly capitalized
    - `'level'`: Integer between 0 and 9
    - `'time'`: String containing the spell's casting time, e.g. `"1 minute"`
    - `'school'`: String.  `"Enchantment"`, `"Evocation"`, etc.
    - `'text'`: Multiline string containing the spell description
    - `'ritual'`: Boolean; `True` if the spell can be cast as a ritual
    - `'duration'`: String similar to `'time'`.
    - `'range'`: String; contains values like `'Self'`, `'Touch'`, `'30 feet'`, etc.
    - `'components'`: currently a String, e.g. `'V, S, M (diamonds worth 300 gp, which the spell consumes)'`

#### Monster fields

Honestly I just can't be arsed to document this right now.  Just check the `__dict__` field.

### `repltools`

`dnd5edb` also includes a `repltools` module.  Currently this is just being used in ipython via

    %run -i repltools.py

from the `dnd5edb` directory.  This command adds a number of objects to the repl namespace.

Currently, most of this module consists of convenience functions and objects
for queries on moon druid wildshaping.
The `beasts` function as well as the `moonws` data structure serve this purpose.
There are also a couple of functions to assist with moon druid multiclass queries:
`bearbarian_ac` and `drunk_ac` (druid/monk == drunk).

These can be used as per the following ipython snippet:

    In [173]: [f'AC:{bearbarian_ac(c)} DEX:{c.dex} CON:{c.con} HP:{c.hp} {c}'
         ...:  for c in moonws[2].sorted(key=bearbarian_ac, reverse=True)    ][:20]
    Out[162]:
    ['AC:16 DEX:17 CON:16 HP:34 Monster(Crag Cat: L unaligned beast, 1.0CR 34HP/4d10+12 13AC (walk 40))',
     'AC:15 DEX:15 CON:15 HP:37 Monster(Dire Wolf: L unaligned beast, 1.0CR 37HP/5d10+10 14AC (walk 50))',
     'AC:15 DEX:16 CON:14 HP:30 Monster(Steeder Female: L unaligned beast, 1.0CR 30HP/4d10+8 14AC (walk 30, climb 30))',
     'AC:15 DEX:16 CON:14 HP:19 Monster(Clawfoot: M Unaligned beast, 1.0CR 19HP/3d8+6 13AC (walk 40))',
     'AC:14 DEX:16 CON:13 HP:11 Monster(Giant Wolf Spider: M unaligned beast, 1/4CR 11HP/2d8+2 13AC (walk 40, climb 40))',
     'AC:14 DEX:18 CON:10 HP:9 Monster(Fastieth: M Unaligned beast, 1/4CR 9HP/2d8 14AC (walk 50))',
     'AC:14 DEX:14 CON:14 HP:19 Monster(Ape: M unaligned beast, 1/2CR 19HP/3d8+6 12AC (walk 30, climb 30))',
     'AC:14 DEX:14 CON:11 HP:16 Monster(Jaculi: L unaligned beast, 1/2CR 16HP/3d10 14AC (walk 30, climb 20))',
     'AC:14 DEX:14 CON:14 HP:45 Monster(Giant Hyena: L unaligned beast, 1.0CR 45HP/6d10+12 12AC (walk 50))',
     'AC:14 DEX:16 CON:12 HP:26 Monster(Giant Spider: L unaligned beast, 1.0CR 26HP/4d10+4 14AC (walk 30, climb 30))',
     'AC:14 DEX:15 CON:13 HP:26 Monster(Lion: L unaligned beast, 1.0CR 26HP/4d10+4 12AC (walk 50))',
     'AC:14 DEX:15 CON:14 HP:37 Monster(Tiger: L unaligned beast, 1.0CR 37HP/5d10+10 12AC (walk 40))',
     'AC:14 DEX:15 CON:14 HP:26 Monster(Deinonychus: M unaligned beast, 1.0CR 26HP/4d8+8 13AC (walk 40))',
     'AC:13 DEX:16 CON:11 HP:4 Monster(Deer: M unaligned beast, 0.0CR 4HP/1d8 13AC (walk 50))',
     'AC:13 DEX:10 CON:12 HP:4 Monster(Giant Fire Beetle: S unaligned beast, 0.0CR 4HP/1d6+1 13AC (walk 30))',
     'AC:13 DEX:15 CON:11 HP:3 Monster(Jackal: S unaligned beast, 0.0CR 3HP/1d6 12AC (walk 40))',
     'AC:13 DEX:16 CON:10 HP:3 Monster(Almiraj: S unaligned beast, 0.0CR 3HP/1d6 13AC (walk 50))',
     'AC:13 DEX:15 CON:11 HP:7 Monster(Giant Rat: S unaligned beast, 1/8CR 7HP/2d6 12AC (walk 30))',
     'AC:13 DEX:15 CON:11 HP:7 Monster(Giant Rat (Diseased): S unaligned beast, 1/8CR 7HP/2d6 12AC (walk 30))',
     'AC:13 DEX:16 CON:10 HP:9 Monster(Giant Weasel: M unaligned beast, 1/8CR 9HP/2d8 13AC (walk 40))']

There is also an `sp` function which provides convenient access to spell information in the author's preferred format:

    In [176]: sp('eldritch blast')
    * Eldritch Blast A/120'/I (0:Wl)
      " A beam of crackling energy streaks toward a creature within range. Make a ranged spell attack against the target. On a hit, the target takes 1d10 force damage.
      " The spell creates more than one beam when you reach higher levels: two beams at 5th level, three beams at 11th level, and four beams at 17th level. you can direct the beams at the same target or at different ones. Make a separate attack roll for each beam.

As documentation for this module is less likely to be updated than that of others, it is best to check the source file `repltools.py` for information on its contents.

### Installation ###

Once you manage to find a copy of the XML database, put it in a subdirectory of the dnd5edb code called `FC5eXML`.
Currently the code looks for the file CoreOnly.xml in that directory.  That file is located in the "Collections" directory of [the DropBox][0].

#### Modules we use

You'll need to install some modules via `pip` (or `pip3`, depending on your installation/distribution/OS).

`pip3 install simpleeval` should cover it.

[0]: https://www.dropbox.com/sh/v4qy66rxi8gpexs/AAADWx5AC55J_A9Ni0rWzWB8a?dl=0&fbclid=IwAR0Vx1n6MmVGuL05jsVsIAvSgUDti1vF5onwA75QGZ3JdWcSk8MgVi4Y12c
[1]: https://ipython.org/
